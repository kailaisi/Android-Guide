## 电量优化你不得不知道的秘密

什么？我写个“破”应用还得管电量？我哪儿知道自己写的应用费不费电啊。。。因为每次谈起“电量优化”这个词，总有一种神秘感，不知从何入手。

但是当我们自己使用手机的时候：这个破应用怎么那么费电？长按，上滑，走起~~~

如果你的应用已经达到了微信这种体量级，用户不得不用的，那你可以翻篇了。

### 基础知识

#### 概述

其实对于一个移动设备来说，有两个耗电大户：CPU和显示屏。为了降低这两个元件的耗电量，在Android系统中，也会通过电源管理来实现降低电量消耗的功能。

对于CPU，大多都会设计两种工作频率，大部分时间内CPU都工作在**降低频率**下，只有**进行密集计算**时，才会切换到高频率。这也就是为什么我们看视频，看直播，玩游戏，上网的时候，会明显感觉手机玩不了多久就得充电的原因。

对于显示屏。系统则会尽量减少亮屏的时间，当用户长时间不操作的时候，就会息屏等等。

#### 电源管理架构

Android系统有一套自己的架构来来实现来实现对于电源的管理。其主要分为四个层次：

**应用接口层**：PowerManger开放给应用一系列的接口，应用可以通过PM的接口来申请wakelock，唤醒系统，使系统进入睡眠等操作。

**Framework层**：应用调用PowerManager开放的接口，来对系统进行一些列的操作是在PowerManagerService中完成的。PMS中处理和电量相关的计算。属于电源管理的决策层。协调与其他模块的交互，比如亮屏、暗屏、系统休眠、唤醒等等。

**HAL层**：power.c文件，通过上层传递下来的参数，向/sys/power/wake_lock或者/sys/power/wake_unlock文件节点写数据与Kernel层进行通信。

**Kernel层**：控制对应的硬件。不管是屏幕还是cpu，统属于硬件，最终通过对硬件的控制来实现对电量管理。

整个架构如下：

![image-20200623135836580](C:\Users\wu\AppData\Roaming\Typora\typora-user-images\image-20200623135836580.png)

**重要的接口**

在电源管理系统中，介绍几个比较的接口。

* userActivity()：报告影响系统休眠的用户活动，重新计算灭屏时间。假设我们手机设置15秒不操作，就息屏。那么我们每次触屏或者滑屏的时候，都会调用这个方法，然后系统会重新进行倒计时的操作。
* Wakelock：提供了相关的接口来操作wakelock锁。比如说申请或者释放等。

#### WakeLock机制

wakelock是一种锁机制，只要有应用拿着这个锁，那么CPU就无法进入休眠，会一直处于工作的状态。

一般手机待机时，LCD、WIFI都会进入休眠状态，Android应用程序的代码也会停止运行。

为了**保证程序中关键代码的正确执行，提供了Wake Lock的API**，使得应用程序能够通过代码阻止CPU进入休眠状态。而这种情况的滥用，则会成为电量杀手。

##### JobScheduler

JobScheduler是安卓5.0推出的API，允许开发者在**符合某些条件时创建执行在后台的任务**。

JobScheduler的目的是为了把一些不是特别紧急的任务放到更合适的时机去批量处理数据。这么做有两个好处：

* 避免频繁的唤醒硬件模块，造成不必要的电量消耗
* 避免在不合适的情况下（如低电量、弱网络或移动网络）下执行过多的任务消耗电量。

#### 耗电统计

耗电统计是一个系统的组件，伴随着系统运行的整个过程。这个统计是基于软件层面实现的，所以不同而硬件模块配置不同的参数，然后使用算法进行估算，谷歌要求OEM厂商必须测量并提供其实际值冰写入到power_profile文件。

### 工具

叨叨那么多，那么我怎么知道我的应用耗电多少啊？其实还是有一些功能能够辅助我们来查询电量的使用情况的。

#### Battery Historian

##### 介绍

Google提供的一套专门分析电量使用的工具。能够**支持Android5.0及以后**的设备商进行电池的相关信息和事件分析。它是一款可视化功能，对于**系统级别和应用级别**的事件都能够**清晰直观**的展现出应用的**耗电比例、执行时间、次数**等等。而且 还支持**两个bugreport文件的对比**，对关键的区别点高亮显示。

##### 使用方式

首先我们看一个常用的cmd命令行指令： 

* 重置电量信息：adb shell dumpsys batterystats --reset

* 开启记录全面的电量信息：adb shell dumpsys batterystats --enable full-wake-history

* 导出：adb bugreport bugreport.zip

在我们进行具体的应用的电量分析的时候，最好是先将电量信息重置。然后操作我们的应用，操作一段时间以后导出bugreport.zip（统计报告）文件。

**注意事项：获取统计报告的时候，需要将统计重置，并断开USB连接，否则将会影响有效性**

当导出zip文件以后，打开[https://bathist.ef.lc/](https://bathist.ef.lc/)。然后上传zip文件。

//todo，上传zip的gif录屏



首先需要将我们手机的相关文件导出。

##### 结果分析

**特点**

可视化分析工具，

#### Energy Profiler

##### 介绍

在搭载 **Android 8.0 (API 26) 或更高版本**的关联设备时，我们可以通过**Profiler**中的**Energy Profiler**来进行电量分析。Energy Profiler能够**监控CPU、网络无线装置和GPS传感器的使用情况**，并**直观**地显示每个组件消耗的电量。而且还能显示可能会影响耗电量的系统事件（唤醒锁定、闹钟、作业和位置信息请求）的发生次数。

Energy Profiler并不会直接测量耗电量，而是使用一种模型来估算设备上每项资源的耗电量。

##### 使用方式

1. 依次选择 **View > Tool Windows > Profiler** 或点击工具栏中的 **Profile** 图标 ![img](https://developer.android.google.cn/studio/images/buttons/toolbar-android-profiler.png)。

   如果 **Select Deployment Target** 对话框显示提示，请选择要将您的应用部署到哪个设备上以进行分析。如果您已通过 USB 连接设备但系统未列出该设备，请确保您已[启用 USB 调试](https://developer.android.google.cn/studio/debug/dev-options#enable)。

2. 点击 **Energy** 时间轴中的任意位置以打开 Energy Profiler。

然后就可以看到如下的图片

![img](http://cdn.qiniu.kailaisii.com/typora/202006/24/161856-5340.png)

如图所示，Energy Profiler 的默认视图包括以下时间轴：

1. **“Event”时间轴**：显示应用中的 Activity 在其生命周期内不断转换而经历各种不同状态的过程。此时间轴还会指示用户与设备的交互，包括屏幕旋转事件。
2. **“Energy”时间轴**：显示应用的估算耗电量。
3. **“System”时间轴**：显示可能会影响耗电量的系统事件。

![image-20200624154458348](http://cdn.qiniu.kailaisii.com/typora/202006/24/154459-592577.png)

当我们发现某一个时刻的耗电量比较高的时候，将鼠标指针放在**Energy**时间轴中的条形上，就可以显示出如上图的说明。这里会显示出CPU、网络和GPS的使用情况。而下面则会会显示**Wake Locks**和对应的**Jobs**信息。

##### 实战分析

这里我们申请了一个wakeLock代码，片段如下：

```java
        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
        PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "test");
        lock.acquire(16 * 1000);
```

**todo//这里增加一个cpu的gif图片**



### 电量优化方案

既然知道手机哪些地方会经常耗电了，而且也能够通过工具对耗电问题的处理。那么我们就说一些开发中需要注意的地方，防止应用比较耗电的情况的发生。

这里我们会根据具体的优化方向来进行分类：

##### CPU

