## C语言基础

### 类型

#### 基本数据类型

c语言的基本数据类型有：int   short   long   double  float   char.

#### 指针

指针是一个变量，存放的是变量的地址（内存地址，系统分配的编号），有类型之分。

在Java中面向对象编程，其实就是指针。

##### 初始化

指针的声明和初始化：

```c
int *p;        // 声明一个指向int 类型的指针 p
char *p        // 声明一个指向char 类型的指针 p
int *arr[10]   // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针
int (*arr)[10] // 声明一个数组指针，该指针指向一个 int 类型的一维数组
int **p;       // 声明一个指针 p ，该指针指向一个 int 类型的指针

/* 方法1：使指针指向现有的内存 */
int x = 1;
int *p = &x;　　// 指针 p 被初始化，指向变量 x ，其中取地址符 & 用于产生操作数内存地址

/* 方法2：动态分配内存给指针 */
int *p;
p = (int *)malloc(sizeof(int) * 10);　　　　// malloc 函数用于动态分配内存
free(p);　　　　// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h
```

##### 指针数组

指针是一个变量，数组是用于存储变量的容器。指针数组是一个数组，数组中的每一个元素都是指针。

```c
int *p[0];//声明一个指针数组，数组有10个元素
```

##### 数组指针

数组指针是一个指针，指针指向数组。可以理解为指向数组0位置的地址

```c
int (*p)[10];//声明一个数组指针，指向一个数组
```

##### 多级指针

指针变量本身是一个变量，它保存的是一个地址信息。如果一个指针指向了另一个指针，那么该指针就是多级指针了。

**意义**

1. 动态分配二维数组，操作数组的时候
2. 在jni.h中的struct JNIEnv结构体中用到

**定义**

```c
    int a = 50;
    int* p1 = &a;
    int** p2 = &p1;//p2是一个二级指针，存放的是p1的值（即a的地址）
    printf("%d",**p2);//多次取值，这里会打印出a的值
    system("pause");
```

##### 函数指针

函数指针是指一个指针指向了某个函数。

```c
void msg(char* msg , char* title){//定义的函数
    //C语言里面字符串用char指针代替
    MessageBox(0,msg,title,0);
}

void main(){
    //直接调用
    msg("内容","标题");
    //函数指针的定义：返回类型，指针名字，参数列表（后面也可以通过typedef关键字来定义一个新的类型）
    //参数名可以省略
    //定义一个函数指针，指向msg函数
    void(*fun)(char* msg, char* title) = msg;
    //使用函数指针去间接调用msg函数
    fun("i love u","kai");
    system("pause");
}
```

#### 字符串

在C语言中，字符串实际上是使用 *null* 字符 ‘\0’终止的一堆字符数组。字符数组的长度包含了末尾的的空字符。

字符串有两种：

* 字符数组实现。可以修改某一个值，不可以整体赋值。
* 字符指针实现。不可以修改其中一个某个值，但是可以整体赋值。使用指针加法和结束符，可以进行截图。

##### 初始化

```cpp
    //使用字符数组，内存连续，可以修改（StringBuilder、Buffer）
    char str1[] = {'a','b','c','\0'};//可以不指定长度，但是需要有结束符
    char str2[6] = {'a','b','c'};//可以指定长度，后面就不会乱码
    char str3[] = "abcdeabcde";//直接用双引号，这时候不用把null放到末尾。
    str3[0] = 's';//可以修改其中某一个字符

    //字符数组不能整体赋值，只能在声明的时候整体赋值，优点是可以局部修改某一个字符。需要重新整体赋值的话，需要使用strcpy
    //str1 = "abcde";

    //字符指针，不需要、不能修改某一个字符串（String）
    char* str4 = "abcdefg";
    //不能修改某一个字符串，否则会提示访问冲突
    //str4[0] = '7';str4++;str4 = "哈哈";

    //但是可以整体赋值
    str4 = "123456";

    //使用指针加法，截取字符串
    str4 += 3;
    while (*str4){
        printf("%c",*str4);
        str4++;
    }
    system("pause");
```

##### 常用方法

| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| ---- | ------------------------------------------------------------ |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

#### 结构体

结构是一个或者多个变量的集合，这些变量的类型可能不同，为了处理的方便讲这些变量组织在一个名字之下。

##### 定义结构

定义结构体，必须使用 **struct** 语句。使用{}来包含多个成员的数据类型。struct数据的格式如下：

```cpp
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
```

这里的tag是结构体标签。而variable-list是结构体**变量**。在定义结构体结构的时候，我们可以在后界面跟上对应的变量。可以是多个，也可以是单个。

```cpp
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;
 
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;
 
//也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;

struct student{//定义一个结构体
    char name[10];
    int age;
    int score;
}
typedef struct student s;//类型定义符，相当于用s来代表student这个结构体
```

对于不同的结构体，哪怕成员变量完全相同，编译器也是将其当做完全不同的类型。

##### 成员变量的访问

C语言中，通过**成员访问运算符（.）**来访问成员变量。

```cpp
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
```

##### 结构体指针

我们可以定义指向结构体的指针，方式和定义其他类型变量的指针相似：

```cpp
struct Books* p = &p2;

printf("%s,%d",(*p).name,(*p).age);//等价于
printf("%s,%d",p->name,p->age);
```



结构体的定义



### 内存分配

#### c语言的内存划分

##### 代码区

存放CPU执行的机器指令。代码区通常是可共享的。而且代码区通常是只读的。

代码区的指令中包含操作符以及要操作的对象（或者对象的引用地址）。如果是立即数（即具体的数值，比如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后应用该数据的地址；如果是BSS和数据取，在代码中同样引用该数据的地址。

##### 全局初始化数据区/静态数据区

只初始化一次。

**数据段**：通常是指用来存放程序中**已经初始化的全局变量**的一块内存区域。**属于静态内存分配。**

##### 未初始化数据区（BSS）

在运行时改变其值。

**BSS段**通常指用来存放程序中**未初始化的全局变量**的一块内存区域。**属于静态内存分配**

##### 栈区

**编译器自动分配和释放。**

存放函数的参数值，局部变量值以及在任务切换时存放当前任务的上下文内容。

每当函数被调用的时候，该**函数返回地址和一些关于调用的信息**，都会被存储到栈区。然后这个**被调用的函数再为它的自动变量和临时变量**在栈区分配空间。

##### 堆区

用于动态内存分配。

堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若不释放，会在程序结束的时候由OS回收。

#### 内存分配方式

在c语言中存在着动态内存分配和静态内存分配。

##### 静态分配

在编译期给变量分配内存空间。属于栈分配。

int a[10]就属于静态分配。

##### 动态分配

在程序运行时给变量分配空间，属于对分配。

int a[n]  或者int *a; a=(int*) malloc(sizeof(int)*n) 都属于动态分配，因为在编译期间，不知道具体分配多少内存。

##### 释放

对于动态分配的内存，需要通过手动释放。而且需要注意，在释放完之后，需要将指针置为NULL。

1. 不能多次释放。
2. 释放完之后，指针仍然有值，给指针置为NULL，标志释放完成。

### 

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

### 编译器

#### 处理过程

1. 预处理阶段
2. 词法与语法分析阶段
3. 编译阶段，编译成汇编，然后再汇编成跟CPU相关的二进制码，生成各个目标文件（.obj文件）
4. 连接阶段，将各个目标文件中的个代码进行绝对地址定位，生成可执行文件。还可以用objcopy生成纯二进制码，去掉文件格式信息。（生成exe文件）

##### .h文件和.c文件区别

.h文件是头文件，内含函数声明、宏定义、结构体定义等内容。有点像java中的接口？

.c文件是程序文件，内含函数实现，变量定义等内容。有点像接口的实现？

#### 宏定义

在头文件中为了防止头文件被重复包含，经常使用

```c
#ifndef cTest_Header_h
#define cTest_Header_h
//头文件内容
#endif
```



