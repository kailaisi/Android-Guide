
## [zookeeper](https://zookeeper.apache.org/)是什么？
> 分布、开源的应用程序协调服务,它是集群的管理者,监视着集群中各个节点的状态，根据节点的反馈进行下一步合理操作。主要解决分布式应用经常遇到的数据管理问题,如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。

简单来说，zookeeper=文件系统+监听通知机制
### 集群搭建
请参考之前的文章:[zk高可用集群方案](http://www.kailaisii.com//archives/zk+redis+codis%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88)
### 概念
#### （1）文件系统
zookeeper维护了一个类似于文件系统的数据结构，就像我们Windows下的文件目录结构似的，很相似~
![image.png](http://cdn.qiniu.kailaisii.com/Fhn6OaMsEdwiGMITRNVKB3eU-G5e)
每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。
##### 节点类型
- PERSISTENT-持久化目录节点
客户端与zookeeper断开连接后，该节点依旧存在
- PERSISTENT_SEQUENTIA 持久化顺序编号目录节点
客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号
- EPHEMERAL-临时目录节点
客户端与zookeeper断开连接后，该节点被删除
- EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点
客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号

#### （2）监听通知机制
客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。

## zookeeper的应用场景
### 一致性配置管理
我们在开发的时候，有时候需要获取一些公共的配置，比如数据库连接信息等，并且偶然可能需要更新配置。如果我们的服务器有N多台的话，那修改起来会特别的麻烦，并且还需要重新启动。这里Zookeeper就可以很方便的实现类似的功能。
#### 实现思路
1. 公共配置存放在Zookeeper节点
2. 应用程序连接到Zookeeper中，并监听配置的节点进行节点变化的监听，当节点变化时，更新配置信息（刷新$(value)?如何实现？）

#### 应用案例
> dubbo
> kafka
> storm

### 分布式锁

在高并发情况下，我们经常需要用到锁机制，在单机时，通常使用synchronized或者lock等来进行并发安全操作，但是对于分布式的资源处理，这种方式就显得乏力。
#### 实现思路
1. 如果锁空间的根节点不存在，首先创建Znode根节点。这里假设为“/test/lock”。这个根节点，代表了一把分布式锁
2. 客户端如果需要占用锁，则在/test/lock下面创建临时的有序的子节点，比如“/test/lock/seq-”。则第一个客户端对应的子节点为“/test/lock/seq-000000000”，第二个为 “/test/lock/seq-000000001”，以此类推。
3. 获取所有的/test/lock下的所有子节点，并排序
4. 判读自己创建的节点是否最小值（第一位）
5. 如果是，则获取得到锁，执行自己的业务逻辑，最后删除这个临时节点。
6. 如果不是最小值，则需要监听自己创建节点前一位节点的数据变化，并阻塞。
7. 当前一位节点被删除时，我们需要通过递归来判断自己创建的节点是否在是最小的，如果是则执行5）；如果不是则执行6）（就是递归循环的判断）
![image.png](http://cdn.qiniu.kailaisii.com/Fgh7fhMdZMhESLXeXaeRyuVjoTgX)
实际的开发中，如果需要使用到分布式锁，并不需要自己造轮子，可以直接使用curator客户端中的各种官方实现的分布式锁
[详细代码实现可参考](https://blog.csdn.net/crazymakercircle/article/details/85956246)
### 分布式队列
在日常使用中，特别是像生产者消费者模式中，经常会使用BlockingQueue来充当缓冲区的角色。但是在分布式系统中这种方式就不能使用BlockingQueue来实现了，但是Zookeeper可以实现。
#### 实现思路

1. 首先利用Zookeeper中临时顺序节点的特点
2. 当生产者创建节点生产时，需要判断父节点下临时顺序子节点的个数，如果达到了上限，则阻塞等待；如果没有达到，就创建节点。
3. 当消费者获取节点时，如果父节点中不存在临时顺序子节点，则阻塞等待；如果有子节点，则获取执行自己的业务，执行完毕后删除该节点即可。
4. 获取最小值，保证了FIFO特性
### 负载均衡
当服务越来越多，规模越来越大时，对应的机器数量也越来越庞大，单靠人工来管理和维护服务及地址的配置信息，已经越来越困难。并且，依赖单一的硬件负载均衡设备或者使用LVS、Nginx等软件方案进行路由和负载均衡调度，单点故障的问题也开始凸显，一旦服务路由或者负载均衡服务器宕机，依赖其的所有服务均将失效。一旦服务器与ZooKeeper集群断开连接，节点也就不存在了，通过注册相应的watcher，服务消费者能够第一时间获知服务提供者机器信息的变更
#### 实现思路
1. 服务提供者在启动时，将其提供的服务名称、服务器地址、以节点的形式注册到服务配置中心
2. 服务消费者通过服务配置中心来获得需要调用的服务名称节点下的机器列表节点
3. 通过负载均衡算法，选取其中一台服务器进行调用
4. 服务消费者只有在第一次调用服务时需要查询服务配置中心，然后将查询到的服务信息缓存到本地，后面的调用直接使用本地缓存的服务地址列表信息，而不需要重新发起请求到服务配置中心去获取相应的服务地址列表，直到服务的地址列表有变更(机器上线或者下线)，变更行为会触发服务消费者注册的相应的watcher进行服务地址的重新查询
### 分布式协调通知
#### 实现思路
1. 不同系统都对 ZK上同一个znode进行注册，监听znode的变化。
2. 其中一个系统update了znode，那么另一个系统能 够收到通知，并作出相应处理。
可用于AMPQ的分布式事务解决方案
![image.png](http://cdn.qiniu.kailaisii.com/FksNUFMh0DGLAuVEFJ9kcP4RX-v1)
### 命名服务
1. 服务A（开发者：小李）需要访问服务B（开发者：小王），但是服务B还在开发过程中（未完成），那么服务A（此时已完成）就不知道如何获取服务B的访问路径了（假设我们使用http服务），小李还有其他工作要做，该怎么办呢？使用zookeeper的服务就可以简单解决：小李和小王约定好：服务B部署成功后，先到zookeeper注册服务（即在zookeeper添加节点/service/B和节点数据）。服务A开发结束后，部署到服务器，然后服务A监控zookeeper服务节点/service/B，如果发现节点数据了，那么服务A就可以访问服务B了。
2. 利用zookeeper顺序节点的特性，制作分布式的ID生成器
