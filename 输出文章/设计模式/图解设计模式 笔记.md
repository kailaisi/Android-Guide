### 设计模式

#### 创建型模式

##### 简单工厂

![../_images/SimpleFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg)

总结：

* 对实例化进行了抽象，将对象的创建和对象的使用进行了分离
* 简单工厂有三个角色：抽象父类，工厂，具体 产品。
* 简单工厂只需要一个具体的参数就可以返回具体的产品，适合于只有少数产品的创建过程
* 简单工厂的优点在于对象的创建和使用进行了隔离，但是工厂类不够灵活，每次新增产品都需要修改工厂类。

##### 工厂方法

![../_images/FactoryMethod.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg)

简单工厂的基础上，将产品的创建交给具体的工厂去实现。所有的工厂都有一个抽象工厂父类。这样需要增加产品的时候，只需要新增工厂和产品即可。无需修改其他的具体工厂和产品。系统的扩展性变得更好，完全符合”开闭原则“。

总结：

* 工厂父类负责创建产品创建的公共接口。
* 工厂方法有四个角色：抽象产品，具体产品，抽象工厂，具体工厂
* 是对简单工厂的进一步抽象和推广。但是在创建新产品时，会同时增加工厂和产品两个类，增加了系统的复杂性。

##### 抽象工厂

![../_images/AbatractFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)



- **产品等级结构** ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
- **产品族** ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

工厂方法中，每个工厂只能创建一个产品。但是有时候一个工厂可能需要创建多个产品（不同等级的产品）

总结

* 抽象工厂提供一系列相关或者相互依赖对象的接口，无需指定具体的类。
* 包含四个角色：抽象工厂，用于声明生成抽象接口的方法；具体工厂，实现抽象工厂；抽象产品，为每种产品定义一定的接口；具体的产品
* 抽象工厂是最为抽象的一种形态。工厂方法是针对一个产品等级结构，抽象工厂则对应多个产品等级。

##### 建造者模式

一些复杂对象的创建，用户不需要关心内部的具体构建细节（可能构建细节比较复杂）。

![../_images/Builder.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg)

角色：

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

总结：

* 将一个复杂对象的创建与表示进行分离。使构建过程可以创建不同的表示。
* 包含四个角色。其中指挥者类隔离了客户和生产，也负责控制产品的生产过程。

##### 单例模式

![../_images/Singleton.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg)

#### 结构型模式

结构型模式，描述的是如何将类或者对象结合在一起形成一个更大的结构。

结构型模式可以分为类结构型模式和对象结构型模式：

- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
- 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。

##### 适配器模式

适配器模式，主要是由于两套接口不兼容，通过适配器来进行接口的转化，从而实现两套接口的适配。

适配器模式包含如下角色：

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类

适配器有两种模式，

**类适配器**

![../_images/Adapter_classModel.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg)

Adaptee没有specificRequest方法，但是用户期望使用这个方法。为了使客户端能够使用这个方法，我们把二者进行衔接，Adapter继承两个类（或者接口），所以这是个类适配器。

```java
//适配者
public class Adaptee {
    public void specificRequest(){
        System.out.println("specificRequest");
    }
}
//目标
public interface Target {
    void request();
}
//适配器
public class Adapter extends Adaptee implements Target {
    @Override
    public void request() {
        specificRequest();
    }
}

// 测试
class AdapterTest {
    public static void main(String[] args) {
        Adapter adapter = new Adapter();
        adapter.request();
    }
}
```

**对象适配器**

![../_images/Adapter.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter.jpg)

与类适配器模式一样，为使客户端能够使用Adaptee类，我们把`Adaptee`与`Target`衔接起来。但这里我们不继承`Adaptee`，而是把`Adaptee`封装进`Adapter`里。这里`Adaptee`与`Adapter`是**组合关系**。

```java
public class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}

class AdapterTest {
    public static void main(String[] args) {
        Adapter adapter = new Adapter(new Adaptee());
        adapter.request();
    }
}
```

类适配器和对象适配器的区别：

类适配器采用的是继承的方式，都是直接继承*Adaptee*，所以无法对其子类进行适配。

对象适配器是使用的组合的方式，对于其子类都可以进行适配。

##### 桥接模式

桥接模式模式，是在适配器中的对象适配器模式的基础上的一种变化，持有的不再是一个具体的对象，而是接口（或者抽象类）。从而实现将抽象部分与实现部分相隔离。

桥接模式包含如下角色：

- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类
- Implementor：实现类接口
- ConcreteImplementor：具体实现类

![../_images/Bridge.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Bridge.jpg)

总结：

* 桥接模式是一种对象结构性模型
* 桥接模式中的抽象和实现进行了脱耦，可以各自沿着自己的维度独立变化。

##### 装饰者模式

一般有两种方式可以实现给一个类或对象增加行为：

- 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
- 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称**这个嵌入的对象为装饰器(Decorator)**

装饰模式包含如下角色：

- Component: 抽象构件
- ConcreteComponent: 具体构件
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类

![../_images/Decorator.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Decorator.jpg)

装饰者模式能够很好的对原有的类扩展而不破环其封装性

##### 享元模式

在很多情况下需要控制系统中类和对象的个数，如果数量太多，可能导致运行代价过高，带来性能下降的问题。

享元模式经常会使用工厂模式，通过工厂来维护一个**享元池**来存储具有相同内部状态的享元对象。

享元模式包含如下角色：

- Flyweight: 抽象享元类
- ConcreteFlyweight: 具体享元类
- UnsharedConcreteFlyweight: 非共享具体享元类
- FlyweightFactory: 享元工厂类

![../_images/Flyweight.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Flyweight.jpg)

总结 ：

* 享元模式使用共享技术支持了大量细粒度对象的复用。是一种对象结构型模式
* 适用的场景：系统有大量相同或者相似的对象，如果大量创建使用，会造成内存的大量消耗；对象的大部分状态都可以外部化。

##### 代理模式

某些情况下，客户不想或者不能直接引用一个对象，可以通过“代理”的方式实现间接引用。

![../_images/Proxy.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg)

总结：

* 代理角色内部持有被代理对象的引用。
* 代理和被代理的对象，都继承相同的接口，来保证可以有相同的行为接口
* 静态代理的需要优先知道要代理的角色，所以会导致系统中类个数的急剧增加，而动态代理可以解决该问题。

#### 行为型模式

行为型模式是对不同对象之间划分责任和算法的抽象类。

##### 命令模式

![../_images/Command.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Command.jpg)

命令模式包含如下角色：

- Command: 抽象命令类
- ConcreteCommand: 具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client:客户类

这里有个命令的接收者，其实是命令的具体的处理和实现类。普通情况下 ，调用者可以直接持有接收者，但是通过命令模式，则可以将二者进行解耦，由Command来持有Receiver，这种情况下，每次扩展新的命令不需要调整已由的类。

总结

* 本质是对命令进行封装。

##### 中介者模式

一个聊天室里面有多个对象，相互之间存在很强的关联性。如果互相持有则耦合性太强，可以通过中介者模式，中介者持有不同的对象，对象调用方法，通过调用中介者来实现。

中介者模式包含如下角色：

- Mediator: 抽象中介者
- ConcreteMediator: 具体中介者
- Colleague: 抽象同事类
- ConcreteColleague: 具体同事类

![../_images/Mediator.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Mediator.jpg)

可以看到，其实同事类是持有中介者的，对于聊天室内其他同事类的相关调用，都交给中介者去处理。

中介者承担两方面的职责：

* 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象不再需要显示引用其他同事，需要通讯时，通过中介者即可。
* 协调作用（行为性）：中介者可以进一步封装，中介者可以在内部封装协调逻辑，从而将同事成员之间的行为进行分离和封装。

通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。

##### 观察者模式

对象与对象之间的依赖关系，当一个对象发生改变时自动通知其他对象，其他对象做出反应。

![../_images/Obeserver.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Obeserver.jpg)

特点：

* 观察者模式可以将表示层和数据逻辑层分离，在观察者和目标之间建立一个抽象的耦合。
* 观察者模式定义了一种**一对多**的依赖关系，让多个观察者可以同时监听同一个目标对象。

##### 状态模式

很多情况下，一个对象的行为取决于一个或者多个动态变化的属性，这种属性叫做状态。当对象与外部事件产生互动时，内部状态会发生变化，从而使得系统的行为也随之发生变化。

状态模式包含如下角色：

- Context: 环境类
- State: 抽象状态类
- ConcreteState: 具体状态类

![../_images/State.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg)

总结：

* 状态模式适用场景：对象的行为依赖于它的状态（属性）并且可以根据他的状态改变而改变它的相关行为；代码中包含大量与状态有关的条件语句，这些语句导致了代码的可维护性和灵活性变差，不能方便的增加和删除状态。
* 描述了对象状态的变化以及在每种状态下表现的不同行为。

**具体的实现案例**

![img](https://img2018.cnblogs.com/blog/1018770/201905/1018770-20190526174737726-2091749380.png)具体的实现案例

#### 策略模式

完成一项任务，可以使用多种不同的方式。

策略模式包含如下角色：

- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类



![../_images/Strategy.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg)



总结：

* 策略模式和状态模式的不同在于：**具体的策略不持有context信息，而具体的状态，因为要切换状态，所以会持有环境类**。
* 策略模式将责任和算法本身分隔开，委派给不同的对象管理。
* 优点在于**对“开闭原则”的完美支持**，能在不修改原系统的基础上更换算法或者新增算法。
* 可以避免危害多重条件选择语句。
