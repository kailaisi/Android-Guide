## 代码重构法则

译文：https://sourcemaking.com/refactoring/smells/long-method

不想写好代码的码农不是好士兵。平时开发用惯了CV大法，在后来的维护过程中发现维护越来越难，慢慢对开发中经常遇到的代码问题提出对应的解决方案。陪我一起走上重构之旅吧，当你回头再遇到相同问题时候，相信会给你新的灵感~

### Swtch分支

**特征**

有一系列的**switch**或者**if**分支操作。

**问题的原因**

尽量减少*switch*和*case*是面向对象编程的标志之一。通常情况下，对于单个的*switch*出现在不同的地方是可以接受的。但是如果增加了新的功能，需要找到原来的*switch*，然后进行修改。

当你遇到这种情况的话，就可以考虑多态。

**解决方案**

* 隔离*switch*，将其放到正确的类中。可能需要**提取法**然后**移动法**。
* 如果*switch*是基于类型的。例如不同的运行模式进行切换。那么使用**用子类替换类型法**和**用策略代替类型法**
* 指定继承关系之后，通过**多态取代条件法**来进行使用。
* 如果没有特别多的分支，而且会调用相同的参数（只是参数不同），这时候没必要使用多态。这种情况下可以将分支内的代码分解为较小的方法。用**显示方法替换成参数法**来取代相关参数。
* 如果有一个分支是*null*，则运用**使用NULL对象法**

##### 忽略优化

* *switch*分支执行简单操作，没有必要做更改。
* *switch*用在工厂设计模式来选择使用哪个类的情况下，不需要优化。

### 重构技巧

#### 提取法

```java
void printOwing() {
  printBanner();
  // Print details.
  System.out.println("name: " + name);
  System.out.println("amount: " + getOutstanding());
}
```

问题：有一段打印的代码可以区分开

```java
void printOwing() {
  printBanner();
  printDetails(getOutstanding());
}

void printDetails(double outstanding) {
  System.out.println("name: " + name);
  System.out.println("amount: " + outstanding);
}
```

解决方案：将这部分代码移到单独的方法中，然后原方法进行调用。

##### 重构原因

一段代码中的行数越多，越难以理解方法的作用。除了简单的移除代码中的肮脏的代码，提取法也是其他重构方法的重要步骤。

##### 好处

* 更易读的代码。确保要给方法取一个描述性的名称 *createOrder()*，*renderCustomerInfo()*等。
* 减少重复的代码。通常情况下，如果一段代码在其他地方有重用的。可以使用调用新方法来来替换。
* 代码片段具有独立性，发生错误的概率更小。

##### 重构方法

1. 创建一个新的方法，取一个具有描述性的名称。
2. 如果提取的代码参数发生了变化，要注意是否会影响主方法。

#### 移动法

问题：一个在A类中的方法，在B类中调用的次数比在A类中调用的次数还多。

解决方案：将方法移到B类中，然后A类通过调用来新的方法。

##### 重构原因

1. 将方法移动到使用该方法最多的类中，这会使得**类的内部一致性**更强。
2. 移动方法以后如果能够减少或者消除对原来的类的依赖关系。那么这种方案能够有效的实现**减少类之间的依赖**

##### 如何重构

要自习分析方法所涉及到的类的特性。如果这个方法只在特定的特性下使用，那么这个特性也应该移动到新类中。如果这个特性可能在其他方法中也有使用，那么这些方法都应该跟着移动到新类中。

1. 要确保方法没有在超类和子类中的声明。否则的话，就应该避免进行移动。也可以通过多态性来保证方法在不同类中的不同功能。
2. 在目标类B中创建一个新的方法。你也许可能想在新的类中创建一个新的方法。
3. 要决定如何在A类中引用目标类B。必须保证已经有返回对象的方法或者字段，没有的话，需要去创建一个新的方法或者字段来保存对象B的信息。
4. 将旧方法转换为对新方法的引用。

#### 用子类替换类型代码

> 类型代码：有一组数字或者字符串，组成了实体的允许值列表时，类型代码就产生了。通常情况下，这些数字或者字符串都被赋予可以理解的名称。

![image-20200611160249605](http://cdn.qiniu.kailaisii.com/typora/202006/11/160250-433138.png)

问题：有一个type的编码类型（这个字段的值可能触发条件的不同代码）

![image-20200611160321893](http://cdn.qiniu.kailaisii.com/typora/202006/11/160322-22951.png)

解决方法：对type对应的值创建对应子类，将相关的行为从原始类提取到子类中。将控制流替换为多态。

##### 重构原因

对于这种类型代码，虽然我们赋予了很容易理解的名称，但是使用的时候仍然会容易出错。例如一个方法接收这些值之一作为一个参数。调用方法的人很可能不会使用*USER_TYPE_ADMIN*这个静态变量来表示*ADMIN*，而是自己输入了小写的*admin*，这种情况就可能会导致程序完全没有按照我们所需要的条件去执行。

##### 好处

* 可以删除分支控制的代码。将代码移动到合适的子类中， 而不是通过笨重的*switch*在原始类中实现。这符合*单一职责原则*。
* 当需要添加新值的时候，只需要添加子类即可，不需要修改现有代码。符合*开放/封闭原则*。

##### 不适合的场景

* 已经有了父类，不能再继承另一个父类了。这种情况下可以通过组合来替换类型代码。

##### 如何重构

2. 使超类构造函数私有（不再对外暴露）。创建静态工厂方法，方法参数和超类构造函数的参数相同。根据编码类型，工厂方法创建子类对象。
2. 为编码类型的每一个值都创建一个唯一子类。
3. 从超类中删除带有类型代码的字段。
4. 然后使用多态，摆脱类型代码的条件。

#### 用多态替换条件

```java
class Bird {
  // ...
  double getSpeed() {
    switch (type) {
      case EUROPEAN:
        return getBaseSpeed();
      case AFRICAN:
        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
      case NORWEGIAN_BLUE:
        return (isNailed) ? 0 : getBaseSpeed(voltage);
    }
    throw new RuntimeException("Should be unreachable");
  }
}
```

问题：这里的代码根据对象的类型或者属性执行不同的操作。

```java
abstract class Bird {
  // ...
  abstract double getSpeed();
}

class European extends Bird {
  double getSpeed() {
    return getBaseSpeed();
  }
}
class African extends Bird {
  double getSpeed() {
    return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
  }
}
class NorwegianBlue extends Bird {
  double getSpeed() {
    return (isNailed) ? 0 : getBaseSpeed(voltage);
  }
}
//客户端
speed = bird.getSpeed();
```

解决方法：创建和条件分支对应的子类。所有的子类都实现一个共同的方法。然后用相关的方法替换条件分支。

##### 好处

* 可以删除重复代码。几乎所有相同的条件都可以去掉。
* 当新增分支的时候，这种方法只需要添加一个新的子类，符合开闭原则。

##### 重构步骤

2. 对于每个子类，重新定义一个统一的方法，将相应条件分支的代码复制到该方法中。
3. 删除条件中的分支
4. 重复以上操作，直到所有的条件分支。
