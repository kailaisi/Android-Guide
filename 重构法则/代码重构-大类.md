## 代码重构-大类

译文：https://sourcemaking.com/refactoring/smells/long-method

不想写好代码的码农不是好士兵。平时开发用惯了CV大法，在后来的维护过程中发现维护越来越难，慢慢对开发中经常遇到的代码问题提出对应的解决方案。陪我一起走上重构之旅吧，当你回头再遇到相同问题时候，相信会给你新的灵感~

### 大类

**特征**

一个类中包含了很多的字段/方法/代码行

![img](https://sourcemaking.com/images/refactoring-illustrations/2x/large-class-1.png)

**问题的原因**

一个类刚创建的时候基本上简短。但是随着时间的推移，它会随着程序的增长而膨胀。

像长方法一样，程序员通常感觉在现有的类中添加一个新特性要比为这段代码创建一个新类更加省事。

**解决方案**

当一个类包含了太多功能的时候，尝试去拆分它：

![img](https://sourcemaking.com/images/refactoring-illustrations/2x/large-class-2.png)

* 如果大类的一部分行为可以拆分为单独的组件，可以参考**提取法**
* 如果大类的的部分行为可以以不同的方式实现，或者很少使用的话，可以使用**提取子类法**
* 如果可以列出客户端可以使用的操作或者行为列表，可以使用**提取接口法**
* 如果大型类负责图形界面，则可以尝试将其某些数据和行为移动到单独的域对象。在这样做时，可能需要将某些数据的副本存储在两个地方，并保持数据的一致性。[重复观测数据](https://sourcemaking.com/refactoring/duplicate-observed-data)提供了一种方法来做这件事。

**结果**

* 这些类的重构，使开发者不必记住大量的类属性
* 大多数情况下，大类的分割能够有效的避免代码和功能的重复

![img](https://sourcemaking.com/images/refactoring-illustrations/2x/large-class-3.png)



### 解决方案

#### 提取法

```java
void printOwing() {
  printBanner();
  // Print details.
  System.out.println("name: " + name);
  System.out.println("amount: " + getOutstanding());
}
```

问题：有一段打印的代码可以区分开

```java
void printOwing() {
  printBanner();
  printDetails(getOutstanding());
}

void printDetails(double outstanding) {
  System.out.println("name: " + name);
  System.out.println("amount: " + outstanding);
}
```

解决方案：将这部分代码移到单独的方法中，然后原方法进行调用。

##### 重构原因

一段代码中的行数越多，越难以理解方法的作用。除了简单的移除代码中的肮脏的代码，提取法也是其他重构方法的重要步骤。

##### 好处

* 更易读的代码。确保要给方法取一个描述性的名称 *createOrder()*，*renderCustomerInfo()*等。
* 减少重复的代码。通常情况下，如果一段代码在其他地方有重用的。可以使用调用新方法来来替换。
* 代码片段具有独立性，发生错误的概率更小。

##### 重构方法

1. 创建一个新的方法，取一个具有描述性的名称。
2. 如果提取的代码参数发生了变化，要注意是否会影响主方法。

#### 提取子类法

![image-20200603162126836](C:\Users\wu\AppData\Roaming\Typora\typora-user-images\image-20200603162126836.png)



问题：在这个类中，对于Job类来说，Employee和UnitPrice属性只会在特殊情况下才会使用。

![img](http://cdn.qiniu.kailaisii.com/typora/202006/03/162133-960849.png)

##### 重构原因

主类中包含了一些比较不常用的字段和方法。虽然这些字段比较少见，但是确确实实与其有关的，所以将相关的字段和方法移动到一个完全独立的类中的话肯定是不对的。所以可以将这些字段转移到子类中。这样父类中只负责大家都关心的事情。

##### 好处

* 快速轻松的创建子类
* 如果主类有多个这样的情况，就可以创建多个单独的子类，将其任务划分的更为具体。

##### 弊端

通过继承可以将类划分不同的类层次。但是有时候也会导致问题。🌰：车有品牌和颜色，可以拆分为两个层次

* 品牌：大众、现在、保时捷....
* 颜色：红色、黑色、白色.....

一切都很好，但是如果我们现在想要的是红色保时捷，问题就出现了。颜色和品牌我们只能选择一个类去创建对象。对于这种情况可以考虑使用装饰者模式。

##### 重构方法

1. 从类中创建一个新的子类。
2. 如果子类需要一些属性的话，创建一个构造方法。莫要忘记调用父类的构造方法。
3. 查看分类的构造方法，如果其中有一些涉及到的属性是子类的，就将这个构造方法移动到子类中。
4. 将必要的字段和方法移动到子类中。
5. 当子类准备好以后。查找方法中所使用的字段。通过多态方法替换掉这些方法中的字段。🌰：*Car*类中有一个字段*isElectricCar*表示是否是电动的，*refuel()*表示汽车要么加油，要么充电。后面的方法是依赖于前面的字段的。重构之后，*isElectricCar*字段可以移除了。而*Car*和*ElectricCar*这两个类中都会有自己的*refuel()*方法。

#### 提取接口法

![image-20200603171945147](C:\Users\wu\AppData\Roaming\Typora\typora-user-images\image-20200603171945147.png)

问题：多个类都使用了相同的类方法。即：两个类中使用的部分方法是一样的。

![image-20200603172125501](http://cdn.qiniu.kailaisii.com/typora/202006/03/172126-524074.png)

解决方法：将相同的方法部分移动到单独的接口中。

##### 重构原因

1. 当类以不同的实现方式来表示同样的功能时，使用接口就特别合适。
2. 通过对接口的限制，能够让所有的子类能够按照自己的需要来实现具体的功能。通过面向接口编程能够屏蔽具体的子类实现。

##### 喜闻乐见

[提取超类](https://sourcemaking.com/refactoring/extract-superclass)和[提取接口](https://sourcemaking.com/refactoring/extract-interface)有很多相似的地方。

提取接口只允许隔离公共接口，而不是公共代码。换句话说，如果类包含重复代码，提取接口并不会帮助您去重复。

尽管如此，这个问题可以通过应用[提取类](https://sourcemaking.com/refactoring/extract-class)将包含复制的行为移动到单独的组件，并将所有工作交给它。如果常见行为的大小很大，则始终可以使用[提取超类](https://sourcemaking.com/refactoring/extract-superclass)。当然，这甚至更容易，但是请记住，如果您选择这条路径，您只会得到一个父类。

##### 重构方法

1. 创建一个空接口。
2. 在接口中声明通用操作。
3. 将必要的类声明为实现接口。
4. 更改客户端代码中的类型声明以使用新接口。

