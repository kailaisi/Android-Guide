## 零拷贝

### 概念

1. I/O内存映射

2. DMA
  传统I/O
  在Java中，我们可以通过InputStream从数据源将数据读取到缓冲区，然后可以通过OutputStream来将数据保存到数据源。这种方式相对来说效率低下。这是因为什么呢？我们看一下传统IO操作，在系统层面发生了什么。
  <img src="https://img-blog.csdn.net/20180122133411574?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA5NjA4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片" style="zoom:50%;" />
加入我们现在有一个需求：将某个图片文件读取出来，然后发送
我们看一下这里面的操作
>1. JVM发出Read()系统请求
>2. OS进行上下文切换，切到内核模式（第一次上下文切换），并将数据从数据源读取到内核缓冲区（第一次数据拷贝：hardware->kernal-buffer）
>3. OS内核将数据从内核缓冲区复制到用户空间缓冲区（第二次拷贝：kernal buffer->user buffer）。到此read()函数返回。系统调用返回导致从内核空间切到用户空间（第二次上下文切换）
>4. JVM处理完代码后调用write()系统请求。
>5. OS进行上下文切换，切到内核模式（第三次上下文切换），并将数据才能给用户空间缓冲区复制到内核缓冲区（第三次拷贝：user buffer->kernal buffer）
>6. write系统返回，从内核空间切换到用户空间（第四次上下文切换）。然后系统将内核缓冲区的数据写到hardware(第四次拷贝：kernal buffer->hardware).。
整体来说，进行了4次上下文的切换和4次的数据拷贝。但是其实是有2次拷贝是没有用的，如果我们直接从hardware读取数据到kernal buffer之后，再从kernal buffer直接写到目标地址就可以了，完全没有必要走一遍用户空间。
### sendfile 实现零拷贝I/O
sendfile()方法是系统提供给我们的一种能够实现我们刚才的需求的一种方案。我们看一下使用sendfile之后的数据流向和上下文切换。
[数据流](https://upload-images.jianshu.io/upload_images/4235178-66c23adafbfbd47f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/418)
我们总结一下具体的流程：
>1. JVM发出transferTo()系统请求
>2. OS进行上下文切换，切到内核模式（第一次上下文切换），通过DMA将数据从数据源读取到内核缓冲区（第一次数据拷贝：hardware->kernal-buffer）
>3. 内核将数据从内核缓冲区拷贝到与socket写核缓冲区（第二次拷贝：user buffer->kernal buffer）
>4. sendfile系统返回，从内核空间切换到用户空间（第二次上下文切换）。然后系统将内核缓冲区的数据写到hardware(第四次拷贝：kernal buffer->hardware).。
通过sendfile实现的零拷贝I/O只使用了2次上下文的切换和3次数据的拷贝。
我们所谓的0拷贝，并不是说真的0次数据的拷贝，而是相对于操作系统层面，没有用户空间和内核空间之间的数据拷贝过程。这就有一个经典的面试题了：0拷贝，是真的一次拷贝都不需要么？答案是显而易见的~~~
### 带有DMA的sendfile实现的零拷贝I/O
